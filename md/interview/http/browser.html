<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器相关 | 面试题收集</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/Interview-record/Interview-record/favicon.ico">
    <meta name="description" content="收录了常见的面试题，希望能帮助到你">
    
    <link rel="preload" href="/Interview-record/assets/css/0.styles.60999250.css" as="style"><link rel="preload" href="/Interview-record/assets/js/app.ea7e96af.js" as="script"><link rel="preload" href="/Interview-record/assets/js/2.a99d1a26.js" as="script"><link rel="preload" href="/Interview-record/assets/js/20.1d30c5bb.js" as="script"><link rel="prefetch" href="/Interview-record/assets/js/10.80cbe7d5.js"><link rel="prefetch" href="/Interview-record/assets/js/11.543defdf.js"><link rel="prefetch" href="/Interview-record/assets/js/12.b62c9fe6.js"><link rel="prefetch" href="/Interview-record/assets/js/13.50362215.js"><link rel="prefetch" href="/Interview-record/assets/js/14.1269e082.js"><link rel="prefetch" href="/Interview-record/assets/js/15.5252d697.js"><link rel="prefetch" href="/Interview-record/assets/js/16.eb879be4.js"><link rel="prefetch" href="/Interview-record/assets/js/17.03ca8f1f.js"><link rel="prefetch" href="/Interview-record/assets/js/18.c0ddfcf8.js"><link rel="prefetch" href="/Interview-record/assets/js/19.74aca5fa.js"><link rel="prefetch" href="/Interview-record/assets/js/3.a9abda9a.js"><link rel="prefetch" href="/Interview-record/assets/js/4.0250c383.js"><link rel="prefetch" href="/Interview-record/assets/js/5.c5fa22d4.js"><link rel="prefetch" href="/Interview-record/assets/js/6.f45840df.js"><link rel="prefetch" href="/Interview-record/assets/js/7.c9822a43.js"><link rel="prefetch" href="/Interview-record/assets/js/8.f8905adf.js"><link rel="prefetch" href="/Interview-record/assets/js/9.3a143eaa.js">
    <link rel="stylesheet" href="/Interview-record/assets/css/0.styles.60999250.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Interview-record/" class="home-link router-link-active"><img src="/Interview-record/biker.svg" alt="面试题收集" class="logo"> <span class="site-name can-hide">面试题收集</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Interview-record/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/Interview-record/md/interview/es6/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/Interview-record/md/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/Xiexiong-zzm/Interview-record.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  仓库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Interview-record/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/Interview-record/md/interview/es6/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/Interview-record/md/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/Xiexiong-zzm/Interview-record.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  仓库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/Interview-record/md/interview/es6/" class="sidebar-heading clickable"><span>ES6</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/Interview-record/md/interview/HTML/" class="sidebar-heading clickable"><span>HTML基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/Interview-record/md/interview/CSS/" class="sidebar-heading clickable"><span>CSS相关</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/Interview-record/md/interview/Algorithms/" class="sidebar-heading clickable"><span>前端常考算法</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/Interview-record/md/interview/http/" class="sidebar-heading clickable router-link-active open"><span>网络相关</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Interview-record/md/interview/http/" aria-current="page" class="sidebar-link">HTTP协议</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Interview-record/md/interview/http/browser.html" aria-current="page" class="active sidebar-link">浏览器相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Interview-record/md/interview/http/browser.html#跨域" class="sidebar-link">跨域</a></li><li class="sidebar-sub-header"><a href="/Interview-record/md/interview/http/browser.html#浏览器安全" class="sidebar-link">浏览器安全</a></li><li class="sidebar-sub-header"><a href="/Interview-record/md/interview/http/browser.html#浏览器缓存" class="sidebar-link">浏览器缓存</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/Interview-record/md/interview/code-rewrite/" class="sidebar-heading clickable"><span>手撕代码</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/Interview-record/md/interview/design-patterns/" class="sidebar-heading clickable"><span>设计模式</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器相关"><a href="#浏览器相关" class="header-anchor">#</a> 浏览器相关</h1> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <h3 id="跨域定义"><a href="#跨域定义" class="header-anchor">#</a> 跨域定义</h3> <p>跨域是指去向一个为非本origin(协议、域名、端口任意一个不同)的目标地址发送请求的过程，这样之所以会产生问题是因为浏览器的同源策略限制。<br>
限制了以下行为：</p> <ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li> <li>DOM 和 JS 对象无法获取</li> <li>Ajax请求发送不出去</li></ul> <h3 id="解决跨域问题"><a href="#解决跨域问题" class="header-anchor">#</a> 解决跨域问题</h3> <ol><li>jsonp<br>
通过script标签传递数据，因为script请求不会被同源策略禁止，所以通过script标签去请求跨域数据，但是jsonp只能实现GET请求</li> <li>CORS--跨域资源共享<br>
CORS又分为简单请求和预检请求
<ul><li>简单请求 mdn定义的简单请求就是某些不会触发cors预检的请求</li></ul> <ol><li>设置不会触发预检的Methods : GET、HEAD、POST</li> <li>简单请求只可以设置如下header如下Accept、Accept-Language、Content-Language、Content-Type</li> <li>Content-Type标头允许的值只能是： application/x-www-form-urlencoded、 multipart/form-data、 text/plain</li></ol> <ul><li>预检请求 预检请求就是在跨域的时候设置了对应的需要预检的内容</li></ul> <ol><li>首先methods设置 PUT、DELETE、CONNECT、OPTIONS、TRACE会导致预检请求</li> <li>设置了Accept、Accept-Language、Content-Language、Content-Type 之外的headers中任一的配置，比如常见的token:authorization,缓存机制cache-control</li> <li>Content-Type设置了简单请求不允许的值，如常用的application/json</li></ol></li> <li>nginx配置代理</li> <li>WebSocket协议跨域</li></ol> <h2 id="浏览器安全"><a href="#浏览器安全" class="header-anchor">#</a> 浏览器安全</h2> <h3 id="xss攻击"><a href="#xss攻击" class="header-anchor">#</a> XSS攻击</h3> <p>XSS 全称是 Cross Site Scripting(即跨站脚本)<br>
通常情况，XSS 攻击的实现有三种方式——存储型、反射型和文档型</p> <ol><li>存储型<br>
存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果</li> <li>反射型<br>
反射型XSS指的是恶意脚本作为网络请求的一部分。</li> <li>文档型<br>
文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！<br>
这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等。</li></ol> <h4 id="防范措施"><a href="#防范措施" class="header-anchor">#</a> 防范措施</h4> <ol><li>对用户的输入进行转码或者过滤</li> <li>利用 CSP（浏览器中的内容安全策略）
<ul><li>限制其他域下的资源加载</li> <li>禁止向其它域提交数据</li> <li>提供上报机制，能帮助我们及时发现 XSS 攻击</li></ul></li> <li>利用 HttpOnly<br>
设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击</li></ol> <h3 id="csrf-跨站请求伪造"><a href="#csrf-跨站请求伪造" class="header-anchor">#</a> CSRF--跨站请求伪造</h3> <ol><li>自动发 GET 请求</li> <li>自动发 POST 请求</li> <li>诱导点击发送 GET 请求</li></ol> <h4 id="防范措施-2"><a href="#防范措施-2" class="header-anchor">#</a> 防范措施</h4> <ol><li>利用Cookie的SameSite属性</li> <li>验证来源站点</li> <li>CSRF Token</li></ol> <h2 id="浏览器缓存"><a href="#浏览器缓存" class="header-anchor">#</a> 浏览器缓存</h2> <h3 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h3> <h4 id="浏览器中的缓存作用分为两种情况-一种需要发送http请求-一种不需要"><a href="#浏览器中的缓存作用分为两种情况-一种需要发送http请求-一种不需要" class="header-anchor">#</a> 浏览器中的缓存作用分为两种情况，一种需要发送http请求，一种不需要</h4> <ul><li>检查强缓存不需要发送发送http请求</li></ul> <ol><li>如何检查？<br>
在HTTP/1.0和HTTP/1.1当中，这个字段是不一样的。在早期，也就是HTTP/1.0时期，使用的是Expires，而HTTP/1.1使用的是Cache-Control。</li> <li>Expires<br>
Expires即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求<br>
存在的问题： 如果服务器的时间和浏览器时间不一致，那服务器返回的过期时间可能是不准确的，http1.1版本中抛弃此种方式</li> <li>Cache-Control:<br>
和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age。例如：</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Cache<span class="token operator">-</span>Control<span class="token operator">:</span>max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">3600</span>
</code></pre></div><ol start="4"><li>其他属性：<br>
public: 客户端和代理服务器都可以缓存。<br>
private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。<br>
no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段<br>
no-store：非常粗暴，不进行任何形式的缓存<br>
s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间<br>
当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑</li></ol> <hr> <h3 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h3> <p>当资源缓存时间超时了，也就是强缓存失效,开始进入<b>协商缓存</b><br>
强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。<br>
缓存tag: Last-Modified 和 ETag</p> <ol><li>Last-Modified 最后修改时间</li></ol> <ul><li>浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间</li> <li>服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比<br>
a. 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。<br>
b. 否则返回304，告诉浏览器直接用缓存</li></ul> <ol start="2"><li>ETag<br>
ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。</li></ol> <ul><li>浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。</li> <li>服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:<br>
a. 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样<br>
b. 否则返回304，告诉浏览器直接用缓存</li></ul> <ol start="3"><li>两者对比</li></ol> <ul><li>在精准度上，ETag优于Last-Modified</li> <li>在性能上，Last-Modified优于ETag<br> <h4>如果两种方式都支持的话，服务器会优先考虑ETag</h4></li></ul> <hr> <h3 id="缓存位置"><a href="#缓存位置" class="header-anchor">#</a> 缓存位置</h3> <p>浏览器缓存位置共四种，按照优先级高低：</p> <ul><li>Service Worker</li> <li>Memory Cache</li> <li>Disk Cache</li> <li>Push Cache</li></ul> <ol><li>Service Worker<br>
主要功能： 离线缓存、消息推送和网络代理等功能</li> <li>Memory Cache<br>
内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了</li> <li>Disk Cache<br>
存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长</li> <li>Push Cache<br>
推送缓存，这是浏览器缓存的最后一道防线</li></ol> <hr> <h3 id="浏览器本地存储"><a href="#浏览器本地存储" class="header-anchor">#</a> 浏览器本地存储</h3> <ol><li>Cookie<br>
Cookie 最开始被设计出来其实并不是来做本地存储的，而是为了弥补HTTP在状态管理上的不足</li></ol> <ul><li>容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。</li> <li>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。</li> <li>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</li></ul> <ol start="2"><li>Local Storage<br>
localStorage有一点跟Cookie一样，就是针对一个域名，即在同一个域名下，会存储相同的一段localStorage。</li></ol> <ul><li>与Cookie的区别：
<ul><li>容量。localStorage 的容量上限为5M，相比于Cookie的 4K 大大增加。当然这个   5M 是针对一个域名的，因此对于一个域名是<strong>持久存储</strong>的。</li> <li>只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问    题和安全问题。</li> <li>接口封装。通过localStorage暴露在全局，并通过它的 setItem 和 getItem等方法 进行操作，非常方便。</li></ul></li> <li>操作方式<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;sanyuan&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;sanyuan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">&quot;info&quot;</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 接着进入相同的域名时就能拿到相应的值:</span>
<span class="token keyword">let</span> name <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> info <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;info&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <ol start="3"><li><p>sessionStorage<br>
和localStorage基本一致，本质区别是sessionStorage不是持久存储，属于会话级别存储，页面关闭后sessionStorage就不存在了。</p></li> <li><p>IndexedDB<br>
IndexedDB是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。</p></li></ol> <ul><li>键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储</li> <li>异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持</li> <li>受同源策略限制，即无法访问跨域的数据库</li></ul> <hr> <h3 id="输入url到页面呈现发生了什么-网络部分"><a href="#输入url到页面呈现发生了什么-网络部分" class="header-anchor">#</a> 输入URL到页面呈现发生了什么---网络部分</h3> <h4 id="构建请求"><a href="#构建请求" class="header-anchor">#</a> 构建请求</h4> <ol><li>浏览器会构建请求行:<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 请求方法是GET，路径为根路径，HTTP协议版本为1.1</span>
<span class="token constant">GET</span> <span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
</code></pre></div></li> <li>查找强缓存<br>
先检查强缓存，如果命中直接使用，否则进入下一步</li> <li>DNS解析<br>
浏览器中输入的是域名，通过DNS解析成IP地址访问，浏览器提供了DNS数据缓存功能，如果一个域名已经解析过，下次会直接使用缓存。</li> <li>建立TCP连接<br>
TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
<ul><li>TCP连接三个阶段</li></ul> <ol><li>通过三次握手(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接</li> <li>进行数据传输。</li> <li>断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。</li></ol></li> <li>发送HTTP请求<br>
现在TCP连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西:请求行、请求头和请求体。
<ul><li>请求行 由请求方法、请求URI和HTTP版本协议组成</li> <li>请求头 一些属性 Cache-Control、If-Modified-Since、If-None-Match等</li> <li>请求体，请求体只有在POST方法下存在，常见的场景是表单提交</li></ul></li> <li>网络响应<br>
响应行、响应头和响应体
<ul><li>响应行  由HTTP协议版本、状态码和状态描述组成</li> <li>响应头  响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息</li> <li>响应体</li></ul></li> <li>总结<br> <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f080b095268038~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="总结图片"></li></ol> <hr> <h3 id="从输入url到页面呈现发生了什么-解析算法篇"><a href="#从输入url到页面呈现发生了什么-解析算法篇" class="header-anchor">#</a> 从输入URL到页面呈现发生了什么？——解析算法篇</h3> <ol><li>构建DOM树</li> <li>样式计算</li> <li>生成布局树(Layout Tree)</li></ol> <h3 id="重绘和回流"><a href="#重绘和回流" class="header-anchor">#</a> 重绘和回流</h3> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f080ba7fa706eb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="流程"></p> <ol><li>回流</li></ol> <ul><li>触发条件： DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流的过程。
<ol><li>一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解</li> <li>使 DOM 节点发生增减或者移动</li> <li>读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作</li> <li>调用 window.getComputedStyle 方法</li></ol></li></ul> <ol start="2"><li>回流过程
依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。<br> <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f0809e65b3d2fc~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="回流"></li> <li>重绘 当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。</li> <li>重绘过程<br> <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f080a26aa222d4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="重绘"></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Interview-record/md/interview/http/" class="prev router-link-active">
        HTTP协议
      </a></span> <span class="next"><a href="/Interview-record/md/interview/code-rewrite/">
        手撕代码
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Interview-record/assets/js/app.ea7e96af.js" defer></script><script src="/Interview-record/assets/js/2.a99d1a26.js" defer></script><script src="/Interview-record/assets/js/20.1d30c5bb.js" defer></script>
  </body>
</html>
