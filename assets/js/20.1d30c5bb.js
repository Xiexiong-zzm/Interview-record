(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{286:function(t,a,s){"use strict";s.r(a);var r=s(13),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器相关"}},[t._v("#")]),t._v(" 浏览器相关")]),t._v(" "),a("h2",{attrs:{id:"跨域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[t._v("#")]),t._v(" 跨域")]),t._v(" "),a("h3",{attrs:{id:"跨域定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨域定义"}},[t._v("#")]),t._v(" 跨域定义")]),t._v(" "),a("p",[t._v("跨域是指去向一个为非本origin(协议、域名、端口任意一个不同)的目标地址发送请求的过程，这样之所以会产生问题是因为浏览器的同源策略限制。"),a("br"),t._v("\n限制了以下行为：")]),t._v(" "),a("ul",[a("li",[t._v("Cookie、LocalStorage 和 IndexDB 无法读取")]),t._v(" "),a("li",[t._v("DOM 和 JS 对象无法获取")]),t._v(" "),a("li",[t._v("Ajax请求发送不出去")])]),t._v(" "),a("h3",{attrs:{id:"解决跨域问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决跨域问题"}},[t._v("#")]),t._v(" 解决跨域问题")]),t._v(" "),a("ol",[a("li",[t._v("jsonp"),a("br"),t._v("\n通过script标签传递数据，因为script请求不会被同源策略禁止，所以通过script标签去请求跨域数据，但是jsonp只能实现GET请求")]),t._v(" "),a("li",[t._v("CORS--跨域资源共享"),a("br"),t._v("\nCORS又分为简单请求和预检请求\n"),a("ul",[a("li",[t._v("简单请求 mdn定义的简单请求就是某些不会触发cors预检的请求")])]),t._v(" "),a("ol",[a("li",[t._v("设置不会触发预检的Methods : GET、HEAD、POST")]),t._v(" "),a("li",[t._v("简单请求只可以设置如下header如下Accept、Accept-Language、Content-Language、Content-Type")]),t._v(" "),a("li",[t._v("Content-Type标头允许的值只能是： application/x-www-form-urlencoded、 multipart/form-data、 text/plain")])]),t._v(" "),a("ul",[a("li",[t._v("预检请求 预检请求就是在跨域的时候设置了对应的需要预检的内容")])]),t._v(" "),a("ol",[a("li",[t._v("首先methods设置 PUT、DELETE、CONNECT、OPTIONS、TRACE会导致预检请求")]),t._v(" "),a("li",[t._v("设置了Accept、Accept-Language、Content-Language、Content-Type 之外的headers中任一的配置，比如常见的token:authorization,缓存机制cache-control")]),t._v(" "),a("li",[t._v("Content-Type设置了简单请求不允许的值，如常用的application/json")])])]),t._v(" "),a("li",[t._v("nginx配置代理")]),t._v(" "),a("li",[t._v("WebSocket协议跨域")])]),t._v(" "),a("h2",{attrs:{id:"浏览器安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器安全"}},[t._v("#")]),t._v(" 浏览器安全")]),t._v(" "),a("h3",{attrs:{id:"xss攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xss攻击"}},[t._v("#")]),t._v(" XSS攻击")]),t._v(" "),a("p",[t._v("XSS 全称是 Cross Site Scripting(即跨站脚本)"),a("br"),t._v("\n通常情况，XSS 攻击的实现有三种方式——存储型、反射型和文档型")]),t._v(" "),a("ol",[a("li",[t._v("存储型"),a("br"),t._v("\n存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果")]),t._v(" "),a("li",[t._v("反射型"),a("br"),t._v("\n反射型XSS指的是恶意脚本作为网络请求的一部分。")]),t._v(" "),a("li",[t._v("文档型"),a("br"),t._v("\n文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！"),a("br"),t._v("\n这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等。")])]),t._v(" "),a("h4",{attrs:{id:"防范措施"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防范措施"}},[t._v("#")]),t._v(" 防范措施")]),t._v(" "),a("ol",[a("li",[t._v("对用户的输入进行转码或者过滤")]),t._v(" "),a("li",[t._v("利用 CSP（浏览器中的内容安全策略）\n"),a("ul",[a("li",[t._v("限制其他域下的资源加载")]),t._v(" "),a("li",[t._v("禁止向其它域提交数据")]),t._v(" "),a("li",[t._v("提供上报机制，能帮助我们及时发现 XSS 攻击")])])]),t._v(" "),a("li",[t._v("利用 HttpOnly"),a("br"),t._v("\n设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击")])]),t._v(" "),a("h3",{attrs:{id:"csrf-跨站请求伪造"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#csrf-跨站请求伪造"}},[t._v("#")]),t._v(" CSRF--跨站请求伪造")]),t._v(" "),a("ol",[a("li",[t._v("自动发 GET 请求")]),t._v(" "),a("li",[t._v("自动发 POST 请求")]),t._v(" "),a("li",[t._v("诱导点击发送 GET 请求")])]),t._v(" "),a("h4",{attrs:{id:"防范措施-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防范措施-2"}},[t._v("#")]),t._v(" 防范措施")]),t._v(" "),a("ol",[a("li",[t._v("利用Cookie的SameSite属性")]),t._v(" "),a("li",[t._v("验证来源站点")]),t._v(" "),a("li",[t._v("CSRF Token")])]),t._v(" "),a("h2",{attrs:{id:"浏览器缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),a("h3",{attrs:{id:"强缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),a("h4",{attrs:{id:"浏览器中的缓存作用分为两种情况-一种需要发送http请求-一种不需要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的缓存作用分为两种情况-一种需要发送http请求-一种不需要"}},[t._v("#")]),t._v(" 浏览器中的缓存作用分为两种情况，一种需要发送http请求，一种不需要")]),t._v(" "),a("ul",[a("li",[t._v("检查强缓存不需要发送发送http请求")])]),t._v(" "),a("ol",[a("li",[t._v("如何检查？"),a("br"),t._v("\n在HTTP/1.0和HTTP/1.1当中，这个字段是不一样的。在早期，也就是HTTP/1.0时期，使用的是Expires，而HTTP/1.1使用的是Cache-Control。")]),t._v(" "),a("li",[t._v("Expires"),a("br"),t._v("\nExpires即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求"),a("br"),t._v("\n存在的问题： 如果服务器的时间和浏览器时间不一致，那服务器返回的过期时间可能是不准确的，http1.1版本中抛弃此种方式")]),t._v(" "),a("li",[t._v("Cache-Control:"),a("br"),t._v("\n和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age。例如：")])]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("Cache"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Control"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("max"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("age"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3600")]),t._v("\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[t._v("其他属性："),a("br"),t._v("\npublic: 客户端和代理服务器都可以缓存。"),a("br"),t._v("\nprivate： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。"),a("br"),t._v("\nno-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段"),a("br"),t._v("\nno-store：非常粗暴，不进行任何形式的缓存"),a("br"),t._v("\ns-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间"),a("br"),t._v("\n当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑")])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),a("p",[t._v("当资源缓存时间超时了，也就是强缓存失效,开始进入"),a("b",[t._v("协商缓存")]),a("br"),t._v("\n强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。"),a("br"),t._v("\n缓存tag: Last-Modified 和 ETag")]),t._v(" "),a("ol",[a("li",[t._v("Last-Modified 最后修改时间")])]),t._v(" "),a("ul",[a("li",[t._v("浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间")]),t._v(" "),a("li",[t._v("服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比"),a("br"),t._v("\na. 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。"),a("br"),t._v("\nb. 否则返回304，告诉浏览器直接用缓存")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("ETag"),a("br"),t._v("\nETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。")])]),t._v(" "),a("ul",[a("li",[t._v("浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。")]),t._v(" "),a("li",[t._v("服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:"),a("br"),t._v("\na. 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样"),a("br"),t._v("\nb. 否则返回304，告诉浏览器直接用缓存")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("两者对比")])]),t._v(" "),a("ul",[a("li",[t._v("在精准度上，ETag优于Last-Modified")]),t._v(" "),a("li",[t._v("在性能上，Last-Modified优于ETag"),a("br"),t._v(" "),a("h4",[t._v("如果两种方式都支持的话，服务器会优先考虑ETag")])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"缓存位置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[t._v("#")]),t._v(" 缓存位置")]),t._v(" "),a("p",[t._v("浏览器缓存位置共四种，按照优先级高低：")]),t._v(" "),a("ul",[a("li",[t._v("Service Worker")]),t._v(" "),a("li",[t._v("Memory Cache")]),t._v(" "),a("li",[t._v("Disk Cache")]),t._v(" "),a("li",[t._v("Push Cache")])]),t._v(" "),a("ol",[a("li",[t._v("Service Worker"),a("br"),t._v("\n主要功能： 离线缓存、消息推送和网络代理等功能")]),t._v(" "),a("li",[t._v("Memory Cache"),a("br"),t._v("\n内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了")]),t._v(" "),a("li",[t._v("Disk Cache"),a("br"),t._v("\n存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长")]),t._v(" "),a("li",[t._v("Push Cache"),a("br"),t._v("\n推送缓存，这是浏览器缓存的最后一道防线")])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"浏览器本地存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器本地存储"}},[t._v("#")]),t._v(" 浏览器本地存储")]),t._v(" "),a("ol",[a("li",[t._v("Cookie"),a("br"),t._v("\nCookie 最开始被设计出来其实并不是来做本地存储的，而是为了弥补HTTP在状态管理上的不足")])]),t._v(" "),a("ul",[a("li",[t._v("容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。")]),t._v(" "),a("li",[t._v("性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。")]),t._v(" "),a("li",[t._v("安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("Local Storage"),a("br"),t._v("\nlocalStorage有一点跟Cookie一样，就是针对一个域名，即在同一个域名下，会存储相同的一段localStorage。")])]),t._v(" "),a("ul",[a("li",[t._v("与Cookie的区别：\n"),a("ul",[a("li",[t._v("容量。localStorage 的容量上限为5M，相比于Cookie的 4K 大大增加。当然这个   5M 是针对一个域名的，因此对于一个域名是"),a("strong",[t._v("持久存储")]),t._v("的。")]),t._v(" "),a("li",[t._v("只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问    题和安全问题。")]),t._v(" "),a("li",[t._v("接口封装。通过localStorage暴露在全局，并通过它的 setItem 和 getItem等方法 进行操作，非常方便。")])])]),t._v(" "),a("li",[t._v("操作方式"),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sanyuan"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("age")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nlocalStorage"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setItem")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sanyuan"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \nlocalStorage"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setItem")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"info"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 接着进入相同的域名时就能拿到相应的值:")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" localStorage"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getItem")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" info "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("localStorage"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getItem")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"info"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("p",[t._v("sessionStorage"),a("br"),t._v("\n和localStorage基本一致，本质区别是sessionStorage不是持久存储，属于会话级别存储，页面关闭后sessionStorage就不存在了。")])]),t._v(" "),a("li",[a("p",[t._v("IndexedDB"),a("br"),t._v("\nIndexedDB是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。")])])]),t._v(" "),a("ul",[a("li",[t._v("键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储")]),t._v(" "),a("li",[t._v("异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持")]),t._v(" "),a("li",[t._v("受同源策略限制，即无法访问跨域的数据库")])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"输入url到页面呈现发生了什么-网络部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输入url到页面呈现发生了什么-网络部分"}},[t._v("#")]),t._v(" 输入URL到页面呈现发生了什么---网络部分")]),t._v(" "),a("h4",{attrs:{id:"构建请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建请求"}},[t._v("#")]),t._v(" 构建请求")]),t._v(" "),a("ol",[a("li",[t._v("浏览器会构建请求行:"),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 请求方法是GET，路径为根路径，HTTP协议版本为1.1")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HTTP")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.1")]),t._v("\n")])])])]),t._v(" "),a("li",[t._v("查找强缓存"),a("br"),t._v("\n先检查强缓存，如果命中直接使用，否则进入下一步")]),t._v(" "),a("li",[t._v("DNS解析"),a("br"),t._v("\n浏览器中输入的是域名，通过DNS解析成IP地址访问，浏览器提供了DNS数据缓存功能，如果一个域名已经解析过，下次会直接使用缓存。")]),t._v(" "),a("li",[t._v("建立TCP连接"),a("br"),t._v("\nTCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。\n"),a("ul",[a("li",[t._v("TCP连接三个阶段")])]),t._v(" "),a("ol",[a("li",[t._v("通过三次握手(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接")]),t._v(" "),a("li",[t._v("进行数据传输。")]),t._v(" "),a("li",[t._v("断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。")])])]),t._v(" "),a("li",[t._v("发送HTTP请求"),a("br"),t._v("\n现在TCP连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西:请求行、请求头和请求体。\n"),a("ul",[a("li",[t._v("请求行 由请求方法、请求URI和HTTP版本协议组成")]),t._v(" "),a("li",[t._v("请求头 一些属性 Cache-Control、If-Modified-Since、If-None-Match等")]),t._v(" "),a("li",[t._v("请求体，请求体只有在POST方法下存在，常见的场景是表单提交")])])]),t._v(" "),a("li",[t._v("网络响应"),a("br"),t._v("\n响应行、响应头和响应体\n"),a("ul",[a("li",[t._v("响应行  由HTTP协议版本、状态码和状态描述组成")]),t._v(" "),a("li",[t._v("响应头  响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息")]),t._v(" "),a("li",[t._v("响应体")])])]),t._v(" "),a("li",[t._v("总结"),a("br"),t._v(" "),a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f080b095268038~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"总结图片"}})])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"从输入url到页面呈现发生了什么-解析算法篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到页面呈现发生了什么-解析算法篇"}},[t._v("#")]),t._v(" 从输入URL到页面呈现发生了什么？——解析算法篇")]),t._v(" "),a("ol",[a("li",[t._v("构建DOM树")]),t._v(" "),a("li",[t._v("样式计算")]),t._v(" "),a("li",[t._v("生成布局树(Layout Tree)")])]),t._v(" "),a("h3",{attrs:{id:"重绘和回流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘和回流"}},[t._v("#")]),t._v(" 重绘和回流")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f080ba7fa706eb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"流程"}})]),t._v(" "),a("ol",[a("li",[t._v("回流")])]),t._v(" "),a("ul",[a("li",[t._v("触发条件： DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流的过程。\n"),a("ol",[a("li",[t._v("一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解")]),t._v(" "),a("li",[t._v("使 DOM 节点发生增减或者移动")]),t._v(" "),a("li",[t._v("读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作")]),t._v(" "),a("li",[t._v("调用 window.getComputedStyle 方法")])])])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("回流过程\n依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。"),a("br"),t._v(" "),a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f0809e65b3d2fc~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"回流"}})]),t._v(" "),a("li",[t._v("重绘 当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。")]),t._v(" "),a("li",[t._v("重绘过程"),a("br"),t._v(" "),a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f080a26aa222d4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"重绘"}})])])])}),[],!1,null,null,null);a.default=e.exports}}]);